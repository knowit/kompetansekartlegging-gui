# Private authorization should ideally be replaced
type Organization
    @model
    @auth(
        rules: [
            { allow: private, operations: [read]} 
            { allow: groups, groups: ["admin"] }
        ]
    )
    @key(
        name: "byName"
        fields: ["orgname"]
        queryField: "organizationByName"
    )
    @key(
        name: "byCreatedAt"
        fields: ["owner", "createdAt"]
        queryField: "organizationByCreatedAt"
    ) {
    id: ID!
    createdAt: AWSDateTime!
    owner: String
    orgname: String!
}

type FormDefinition
    @model
    @auth(
        rules: [
            # { allow: private, operations: [read] }
            # { allow: groups, groups: ["admin"] }
            { allow: groups, groupsField: "orgAdmins" }
            { allow: groups, groupsField: "organizationID", operations: [read] }
        ]
    )
    @key(
        name: "byCreatedAt"
        fields: ["sortKeyConstant", "createdAt"]
        queryField: "formByCreatedAt"
    )
    @key(
        name: "byOrganization"
        fields: ["organizationID"]
        queryField: "formDefinitionByOrganizationID"
    ) {
    id: ID!
    label: String
    createdAt: AWSDateTime!
    sortKeyConstant: String!
    questions: [Question]
        @connection(keyName: "byFormDefinition", fields: ["id"])
    organizationID: ID!
    organization: Organization @connection(fields:["organizationID"])
    organizationGroup: String # Hva skal vi med dette feltet_
    orgAdmins: String
}

type UserForm
    @model
    @auth(
        rules: [
            { allow: owner }
            # { allow: groups, groups: ["admin"] }
            # { allow: groups, groups: ["groupLeader"], operations: [read] }
            { allow: groups, groupsField: "orgAdmins" }
            { allow: groups, groupsField: "orgGroupLeaders", operations: [read] }
        ]
    )
    @key(
        name: "byCreatedAt"
        fields: ["owner", "createdAt"]
        queryField: "userFormByCreatedAt"
    ) {
    id: ID!
    createdAt: AWSDateTime!
    owner: String
    formDefinitionID: ID!
    questionAnswers: [QuestionAnswer]!
        @connection(keyName: "byUserForm", fields: ["id"])
    formDefinition: FormDefinition! @connection(fields: ["formDefinitionID"])
    
    orgGroupLeaders: String
    orgAdmins: String
}

type QuestionAnswer
    @model
    @auth(
        rules: [
            { allow: owner }
            # { allow: groups, groups: ["admin"] }
            # { allow: groups, groups: ["groupLeader"], operations: [read] }
            { allow: groups, groupsField: "orgAdmins" }
            { allow: groups, groupsField: "orgGroupLeaders", operations: [read] }
        ]
    )
    @key(name: "byUserForm", fields: ["userFormID"]) {
    id: ID!
    userFormID: ID!
    questionID: ID!
    question: Question @connection(fields: ["questionID"])
    orgGroupLeaders: String
    orgAdmins: String
    

    # if question.type == null or knowledgeMotivation
    knowledge: Float
    motivation: Float

    # if question.type == customScaleLabels
    customScaleValue: Float

    # if question.type == text
    textValue: String
}

enum QuestionType {
    knowledgeMotivation
    customScaleLabels
    text
}

# {allow:private, operations: [read]} er ikke sikkert, gir hvem som helst som har bruker muligheten til å hente
# spørsmålene til alle organisasjoner
type Question
    @model
    @auth(
        rules: [
            { allow: private, operations: [read] }
            # { allow: groups, groups: ["admin"] }
            { allow: groups, groupsField: "orgAdmins" }
        ]
    )
    @key(
        name: "byFormDefinition"
        fields: ["formDefinitionID"]
        queryField: "questionsByFormDefinition"
    )
    @key(
        name: "byCategory"
        fields: ["categoryID"]
        queryField: "questionsByCategory"
    ) {
    id: ID!
    text: String!
    topic: String!
    index: Int
    formDefinitionID: ID!
    categoryID: ID!
    category: Category @connection(fields: ["categoryID"])
    type: QuestionType

    # if type == customScaleLabels
    scaleStart: String
    scaleMiddle: String
    scaleEnd: String
    
    orgAdmins: String
}

# {allow:private, operations: [read]} er ikke sikkert, gir hvem som helst som har bruker muligheten til å hente 
# kategoriene til alle organisasjoner
type Category
    @model
    @auth(
        rules: [
            { allow: private, operations: [read] }
            # { allow: groups, groups: ["admin"] }
            { allow: groups, groupsField: "orgAdmins" }
        ]
    )
    @key(
        name: "byFormDefinition"
        fields: ["formDefinitionID"]
        queryField: "categoriesByFormDefinition"
    ) {
    id: ID!
    text: String!
    description: String
    index: Int
    formDefinitionID: ID!
    formDefinition: FormDefinition @connection(fields: ["formDefinitionID"])
    questions: [Question] @connection(keyName: "byCategory", fields: ["id"])

    orgAdmins: String
}

type Group
    @model
    @auth(
        rules: [
            # { allow: groups, groups: ["admin"] }
            # { allow: groups, groups: ["groupLeader"], operations: [read] }
            { allow: groups, groupsField: "orgAdmins" }
            { allow: groups, groupsField: "orgGroupLeaders", operations: [read] }
        ]
    ) {
    id: ID!
    groupLeaderUsername: String!
    orgID: ID!
    organization: Organization @connection(fields: ["orgID"])
    orgGroupLeaders: String
    orgAdmins: String
}

# Må endres til at access reguleres med orgGroupLeader og orgAdmin
type User
    @model
    @auth(
        rules: [
            { allow: groups, groups: ["admin"] }
            { allow: groups, groups: ["groupLeader"] }
            { allow: groups, groupsField: "orgGroups" }
        ]
    )
    @key(name: "byGroup", fields: ["groupID"], queryField: "usersByGroup") {
    id: ID!
    groupID: ID!
    group: Group! @connection(fields: ["groupID"])
    orgID: ID!
    organization: Organization @connection(fields: ["orgID"])
    orgGroups: [String]
}

type CreateQuestionAnswerResult {
    status: Int!
    error: String
    failedInputs: [CreateQuestionAnswerFailedInput]
}

type CreateQuestionAnswerFailedInput {
    id: ID
    userFormID: ID!
    questionID: ID!
    knowledge: Float
    motivation: Float
    customScaleValue: Float
    formDefinitionID: String!
}

input CreateQuestionAnswerInput {
    id: ID
    userFormID: ID!
    questionID: ID!
    knowledge: Float
    motivation: Float
    customScaleValue: Float
    formDefinitionID: String!
    orgAdmins: String
    orgGroupLeaders: String
}

type Mutation {
    batchCreateQuestionAnswer(
        input: [CreateQuestionAnswerInput]
        organizationID: String
    ): CreateQuestionAnswerResult @function(name: "createUserformBatch-${env}")
}
